# 1、实习和项目经历（较详细） 遇到了什么问题，怎么解决的

2、用了什么数据库（MySQL、Hive） 读写数据量大不大 用了什么引擎？（InnoDB） MyISAM引擎用过没有？有什么区别？ MyISAM具体用的用途是什么（我没答上来）
3、数据库相关隔离级别介绍下。什么脏读、可重复读、幻读等等（建议从网上找一个具体的例子看看，面试官问了具体的会话，见4）你现在用的是什么隔离级别
4、两个事务A、B，A是未提交，A读了一个数据，B对数据进行写，A再次读读的是什么数据？
5、我专业不是计算机专业的，问了下和计算机专业的关系，都学了写什么相关的理论。

# 6、排序相关算法，时间复杂度都是怎么样的。

冒泡排序：最好的情况是数据本来就有序，复杂度为O(n)；最差的情况是O(N^2),稳定算法。

选择排序：最好的情况是数据本来就有序，复杂度为O(n)；最差的情况是O(N^2),不稳定算法

直接插入排序：最好的情况是数据本来就有序，复杂度为O(n)；最差的情况是O(N^2),稳定算法

希尔排序：最好的情况复杂度为O(n)；最差的情况是O(N^2),但平均复杂度要比直接插入小，不稳定算法

快速排序：最好的情况复杂度为NlogN,最差的情况是O(N^2),快速排序将不幸退化为冒泡排序;不稳定(比如序列5 3 3 4 3 8 9 10 11，现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱) ave O(N*log2N) 
归并排序：所有情况下都是NlogN，稳定算法。







7、对于单链表来说，比较好的排序是什么？（因为链表没办法找到前几个节点，所以适合数据的算法不适合链表） 随便问了下堆排序的大体算法。
# 8、队列和栈。两个栈怎么实现队列？

使用两个栈A,B，其中假定A负责push操作，B负责pop操作





# 9、一群数字如何去重？







10、给栈加个辅助功能，实现得到栈此时的最小元素【加一个最小栈，每次入栈时判断最小栈顶元素和入栈大小，把小的插入到最小栈中】
11、Java并发 内存管理 并发？什么场景遇到过？怎么解决？
12、OOM什么时候遇到过？OOM时程序有什么表现？进程消掉了还是线程死掉了？





# 1、String 、StringBuilder、StringBuffer的区别String是否线程安全?

String 字符串常量

[StringBuffer](https://so.csdn.net/so/search?q=StringBuffer) 字符串变量(线程安全)

StringBuilder 字符串变量(非[线程安全](https://so.csdn.net/so/search?q=线程安全))



每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String 。



StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。



1、StringBuffer多线程安全，但是加了synchronized，其效率低。故适用于多线程下，并发量不是很高的场景

2、StringBuilder没有加任何锁，其效率高，适用单线程场景，但同时也适用于高并发场景中，提高高并发场景下程序的响应性能，至于线程安全问题可以通过其它手段解决，如ThreadLocal，CAS操作等。

3、所以对于高并发场景下，若有用到二者，还是建议优先使用StringBuilder的



## 什么是线程安全

如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

或者说:一个类或者程序所提供的接口对于线程来说是原子操作或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题。




# 2、wait()和sleep的区别是什么?

sleep() 方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。



wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程



其实就是能否释放对象锁的问题，
Thread.sleep()不释放对象锁，
Object.wait()释放对象锁，同时要搭配notifyAll()来唤醒



sleep和锁没有任何关系。

# 3、被final修饰的特点是什么?

1、final修饰的类不可以被继承，但可以继承其他的类。

2、final修饰的方法子类可以继承但是不能重写。

3、子类重写父类的非final方法可以加上final。

4、被final修饰的基本数据类型的变量可以看作是常量，赋值后不能改变。

5、被final修饰的引用数据类型变量的引用内存地址值不能改变，可以改变引用数据类型变量的属性值。

6、被final修饰的成员变量必须在对象创建完成前进行赋值，可以直接赋值，如果没有直接赋值则需要用构造方法进行赋值，如果有多个构造方法则多个构造方法都要为其赋值，但是不能用set方法赋值。

7、成员变量在堆内存中是有默认值的，final固定的是成员变量的手动赋值不是内存中的默认值。

8、被final修饰的静态成员变量只能直接赋值或者通过静态代码块赋值。



# 4、接口和抽象类的区别是什么?

第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。
第二点． 接口可以多继承，抽象类不行
第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。
第四点． 接口中基本数据类型为static 而抽类象不是的。



一个类只能继承一个抽象类，而一个类可以实现多个接口。
抽象类可以有构造方法，接口中不能有构造方法。
抽象类中可以有成员变量，接口中没有成员变量。（被final修饰变成了常量）
抽象类中可以有普通方法，接口中所有方法都必须是抽象的。（1.8后允许接口定义非抽象方法）
抽象类中抽象方法的访问类型可以是public，protected，但接口中抽象方法的访问类型只能是public，并且默认为public abstract（省略则自动默认补全）。



接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。

抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人

当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。





# 5、synchroized和lock的区别是什么?

一、synchronized是java内置关键字，在jvm层面，Lock是个java类;

二、synchronized不能够判断是否获取锁的状态，Lock能够判断是否获取到锁;

三、synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ;b

线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁(unlock()方法释放锁)，否则容易造成线程死锁;

四、用synchronized关键字的两个线程1和线程2，当前线程1获得锁，线程2线程等待。当线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，假如尝试获取不到锁，线程可以不用一直等待就结束了;

五、synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平(两者都可以)

六、Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。











# CAS操作

- [Compare](https://so.csdn.net/so/search?q=Compare) and Swap，即比较再交换。

- 意思是指在操作之前先比较该值有没有变化，只有在没变的情况下才对其赋值。

**借助了CAS指令实现了一种区别于synchronized的一种乐观锁**





# 数据库索引 b+树特点是什么?

